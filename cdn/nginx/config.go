/*
 *     Copyright 2020 The Dragonfly Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package nginx

import (
	"fmt"
	"os"
	"path/filepath"

	"d7y.io/dragonfly/v2/pkg/basic"
)

// Config defines nginx configuration.
type Config struct {
	// CmdPath is the nginx binary command path
	CmdPath string `yaml:"cmdPath"`
	// TargetConfPath is the target nginx configuration path generated by program
	TargetConfPath string `yaml:"targetConfPath"`
	// TemplatePath takes precedence over default template.
	TemplatePath string `yaml:"templatePath"`
	// LogDir is the path pf log file
	LogDir string `yaml:"logDir"`
	// TLS is the nginx ssl configuration
	TLS TLSConfig `yaml:"tls"`
}

func (c *Config) populateParams(params map[string]interface{}) map[string]interface{} {
	params["access_log_path"] = filepath.Join(c.LogDir, "nginx-access.log")
	params["error_log_path"] = filepath.Join(c.LogDir, "nginx-error.log")
	params["ssl_enabled"] = c.TLS.Enabled
	if c.TLS.Enabled {
		params["ssl_certificate"] = c.TLS.Cert.Path
		params["ssl_certificate_key"] = c.TLS.Key.Path
	}
	return params
}

// TLSConfig defines TLS configuration.
// Both Cert and Key should be already in pem format.
type TLSConfig struct {
	Enabled bool   `yaml:"enabled"`
	Cert    Secret `yaml:"cert"`
	Key     Secret `yaml:"key"`
}

// Secret contains secret path configuration.
type Secret struct {
	Path string `yaml:"path"`
}

func DefaultConfig() Config {
	config := Config{}
	return config.applyDefaults()
}

func (c Config) applyDefaults() Config {
	if c.CmdPath == "" {
		c.CmdPath = DefaultNginxCmdPath
	}
	if c.TargetConfPath == "" {
		c.TargetConfPath = DefaultConfPath
	}
	if c.LogDir == "" {
		c.LogDir = DefaultLogPath
	}
	return c
}

func (c Config) Validate() []error {
	var errors []error
	if _, err := os.Stat(c.CmdPath); err != nil {
		errors = append(errors, fmt.Errorf("nginx executable file %s must existï¼Œdefault is %s", c.CmdPath, DefaultNginxCmdPath))
	}
	if c.TargetConfPath == "" {
		errors = append(errors, fmt.Errorf("nginx configuration file must be specified"))
	}
	if c.LogDir == "" {
		errors = append(errors, fmt.Errorf("nginx log directory must be specified"))
	}
	if c.TLS.Enabled {
		if _, err := os.Stat(c.TLS.Cert.Path); err != nil {
			errors = append(errors, fmt.Errorf("invalid TLS cert config: %v", err))
		}
		if _, err := os.Stat(c.TLS.Key.Path); err != nil {
			errors = append(errors, fmt.Errorf("invalid TLS private key config: %v", err))
		}
	}
	return errors
}

var (
	DefaultNginxCmdPath = "/usr/local/bin/nginx"

	DefaultLogPath = filepath.Join(basic.HomeDir, "logs", "nginx")

	DefaultConfPath = filepath.Join(basic.HomeDir, "conf", "nginx.conf")
)
